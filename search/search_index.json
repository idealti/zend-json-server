{
    "docs": [
        {
            "location": "/",
            "text": "zend-json-server\n\n\n\n\n\n\nProvides a JSON-RPC server implementation.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-json-server/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-json-server/",
            "title": "zend-json-server"
        },
        {
            "location": "/#zend-json-server",
            "text": "Provides a JSON-RPC server implementation.   File issues at https://github.com/zendframework/zend-json-server/issues  Documentation is at https://docs.zendframework.com/zend-json-server/",
            "title": "zend-json-server"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-json-server is a \nJSON-RPC\n server implementation.\nIt supports both the \nJSON-RPC version 1 specification\n as\nwell as the \nversion 2 specification\n; additionally, it\nprovides a PHP implementation of the \nService Mapping Description (SMD)\nspecification\n for providing service metadata to service\nconsumers.\n\n\nJSON-RPC is a lightweight Remote Procedure Call protocol that utilizes JSON for its messaging\nenvelopes. This JSON-RPC implementation follows PHP's\n\nSoapServer\n API. This means, in a typical\nsituation, you will simply:\n\n\n\n\nInstantiate the server object.\n\n\nAttach one or more functions and/or classes/objects to the server object.\n\n\nhandle()\n the request.\n\n\n\n\nzend-json-server utilizes \nZend\\Server\\Reflection\n\nto perform reflection on any attached classes or functions, and uses that\ninformation to build both the SMD and enforce method call signatures. As such,\nit is imperative that any attached functions and/or class methods have full\nPHP docblocks documenting, minimally:\n\n\n\n\nAll parameters and their expected variable types\n\n\nThe return value variable type\n\n\n\n\nzend-json-server listens for POST requests only at this time; fortunately, most\nJSON-RPC client implementations in the wild at the time of this writing will\nonly POST requests as it is. This makes it simple to utilize the same server\nend point to both handle requests as well as to deliver the service SMD, as is\nshown in the next example.",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-json-server is a  JSON-RPC  server implementation.\nIt supports both the  JSON-RPC version 1 specification  as\nwell as the  version 2 specification ; additionally, it\nprovides a PHP implementation of the  Service Mapping Description (SMD)\nspecification  for providing service metadata to service\nconsumers.  JSON-RPC is a lightweight Remote Procedure Call protocol that utilizes JSON for its messaging\nenvelopes. This JSON-RPC implementation follows PHP's SoapServer  API. This means, in a typical\nsituation, you will simply:   Instantiate the server object.  Attach one or more functions and/or classes/objects to the server object.  handle()  the request.   zend-json-server utilizes  Zend\\Server\\Reflection \nto perform reflection on any attached classes or functions, and uses that\ninformation to build both the SMD and enforce method call signatures. As such,\nit is imperative that any attached functions and/or class methods have full\nPHP docblocks documenting, minimally:   All parameters and their expected variable types  The return value variable type   zend-json-server listens for POST requests only at this time; fortunately, most\nJSON-RPC client implementations in the wild at the time of this writing will\nonly POST requests as it is. This makes it simple to utilize the same server\nend point to both handle requests as well as to deliver the service SMD, as is\nshown in the next example.",
            "title": "Introduction"
        },
        {
            "location": "/usage/",
            "text": "Basic Usage\n\n\nFirst, let's define a class we wish to expose via the JSON-RPC server. We'll\ncall the class \nCalculator\n, and define methods for \nadd\n, \nsubtract\n,\n\nmultiply\n, and \ndivide\n:\n\n\n/**\n * Calculator - sample class to expose via JSON-RPC\n */\nclass Calculator\n{\n    /**\n     * Return sum of two variables\n     *\n     * @param  int $x\n     * @param  int $y\n     * @return int\n     */\n    public function add($x, $y)\n    {\n        return $x + $y;\n    }\n\n    /**\n     * Return difference of two variables\n     *\n     * @param  int $x\n     * @param  int $y\n     * @return int\n     */\n    public function subtract($x, $y)\n    {\n        return $x - $y;\n    }\n\n    /**\n     * Return product of two variables\n     *\n     * @param  int $x\n     * @param  int $y\n     * @return int\n     */\n    public function multiply($x, $y)\n    {\n        return $x * $y;\n    }\n\n    /**\n     * Return the division of two variables\n     *\n     * @param  int $x\n     * @param  int $y\n     * @return float\n     */\n    public function divide($x, $y)\n    {\n        return $x / $y;\n    }\n}\n\n\n\nNote that each method has a docblock with entries indicating each parameter and\nits type, as well as an entry for the return value. This is \nabsolutely\ncritical\n when utilizing zend-json-server or any other server component in\nZend Framework, for that matter.\n\n\nNow we'll create a script to handle the requests:\n\n\n$server = new Zend\\Json\\Server\\Server();\n\n// Indicate what functionality is available:\n$server->setClass('Calculator');\n\n// Handle the request:\n$server->handle();\n\n\n\nHowever, this will not address the issue of returning an SMD so that the\nJSON-RPC client can autodiscover methods. That can be accomplished by\ndetermining the HTTP request method, and then specifying some server\nmetadata:\n\n\n$server = new Zend\\Json\\Server\\Server();\n$server->setClass('Calculator');\n\nif ('GET' == $_SERVER['REQUEST_METHOD']) {\n    // Indicate the URL endpoint, and the JSON-RPC version used:\n    $server->setTarget('/json-rpc.php')\n           ->setEnvelope(Zend\\Json\\Server\\Smd::ENV_JSONRPC_2);\n\n    // Grab the SMD\n    $smd = $server->getServiceMap();\n\n    // Return the SMD to the client\n    header('Content-Type: application/json');\n    echo $smd;\n    return;\n}\n\n$server->handle();\n\n\n\nIf utilizing the JSON-RPC server with Dojo toolkit, you will also need to set a\nspecial compatibility flag to ensure that the two interoperate properly:\n\n\n$server = new Zend\\Json\\Server\\Server();\n$server->setClass('Calculator');\n\nif ('GET' == $_SERVER['REQUEST_METHOD']) {\n    $server->setTarget('/json-rpc.php')\n           ->setEnvelope(Zend\\Json\\Server\\Smd::ENV_JSONRPC_2);\n    $smd = $server->getServiceMap();\n\n    // Set Dojo compatibility:\n    $smd->setDojoCompatible(true);\n\n    header('Content-Type: application/json');\n    echo $smd;\n    return;\n}\n\n$server->handle();",
            "title": "Basic Usage"
        },
        {
            "location": "/usage/#basic-usage",
            "text": "First, let's define a class we wish to expose via the JSON-RPC server. We'll\ncall the class  Calculator , and define methods for  add ,  subtract , multiply , and  divide :  /**\n * Calculator - sample class to expose via JSON-RPC\n */\nclass Calculator\n{\n    /**\n     * Return sum of two variables\n     *\n     * @param  int $x\n     * @param  int $y\n     * @return int\n     */\n    public function add($x, $y)\n    {\n        return $x + $y;\n    }\n\n    /**\n     * Return difference of two variables\n     *\n     * @param  int $x\n     * @param  int $y\n     * @return int\n     */\n    public function subtract($x, $y)\n    {\n        return $x - $y;\n    }\n\n    /**\n     * Return product of two variables\n     *\n     * @param  int $x\n     * @param  int $y\n     * @return int\n     */\n    public function multiply($x, $y)\n    {\n        return $x * $y;\n    }\n\n    /**\n     * Return the division of two variables\n     *\n     * @param  int $x\n     * @param  int $y\n     * @return float\n     */\n    public function divide($x, $y)\n    {\n        return $x / $y;\n    }\n}  Note that each method has a docblock with entries indicating each parameter and\nits type, as well as an entry for the return value. This is  absolutely\ncritical  when utilizing zend-json-server or any other server component in\nZend Framework, for that matter.  Now we'll create a script to handle the requests:  $server = new Zend\\Json\\Server\\Server();\n\n// Indicate what functionality is available:\n$server->setClass('Calculator');\n\n// Handle the request:\n$server->handle();  However, this will not address the issue of returning an SMD so that the\nJSON-RPC client can autodiscover methods. That can be accomplished by\ndetermining the HTTP request method, and then specifying some server\nmetadata:  $server = new Zend\\Json\\Server\\Server();\n$server->setClass('Calculator');\n\nif ('GET' == $_SERVER['REQUEST_METHOD']) {\n    // Indicate the URL endpoint, and the JSON-RPC version used:\n    $server->setTarget('/json-rpc.php')\n           ->setEnvelope(Zend\\Json\\Server\\Smd::ENV_JSONRPC_2);\n\n    // Grab the SMD\n    $smd = $server->getServiceMap();\n\n    // Return the SMD to the client\n    header('Content-Type: application/json');\n    echo $smd;\n    return;\n}\n\n$server->handle();  If utilizing the JSON-RPC server with Dojo toolkit, you will also need to set a\nspecial compatibility flag to ensure that the two interoperate properly:  $server = new Zend\\Json\\Server\\Server();\n$server->setClass('Calculator');\n\nif ('GET' == $_SERVER['REQUEST_METHOD']) {\n    $server->setTarget('/json-rpc.php')\n           ->setEnvelope(Zend\\Json\\Server\\Smd::ENV_JSONRPC_2);\n    $smd = $server->getServiceMap();\n\n    // Set Dojo compatibility:\n    $smd->setDojoCompatible(true);\n\n    header('Content-Type: application/json');\n    echo $smd;\n    return;\n}\n\n$server->handle();",
            "title": "Basic Usage"
        },
        {
            "location": "/server/",
            "text": "Zend\\Json\\Server\\Server\n\n\nZend\\Json\\Server\\Server\n is the core class in the JSON-RPC offering; it\nhandles all requests and returns the response payload. It has the following\nmethods:\n\n\n\n\naddFunction($function)\n: Specify a userland function to attach to the server.\n\n\nsetClass($class)\n: Specify a class or object to attach to the server; all\n  public methods of that item will be exposed as JSON-RPC methods.\n\n\nfault($fault = null, $code = 404, $data = null)\n: Create and return a\n  \nZend\\Json\\Server\\Error\n object.\n\n\nhandle($request = false)\n: Handle a JSON-RPC request; optionally, pass a\n  \nZend\\Json\\Server\\Request\n object to utilize (creates one by default).\n\n\ngetFunctions()\n: Return a list of all attached methods.\n\n\nsetRequest(Zend\\Json\\Server\\Request $request)\n: Specify a request object for\n  the server to utilize.\n\n\ngetRequest()\n: Retrieve the request object used by the server.\n\n\nsetResponse(Zend\\Json\\Server\\Response $response)\n: Set the response object\n  for the server to utilize.\n\n\ngetResponse()\n: Retrieve the response object used by the server.\n\n\nsetAutoEmitResponse($flag)\n: Indicate whether the server should\n  automatically emit the response and all headers; by default, this is \nTRUE\n.\n\n\nautoEmitResponse()\n: Determine if auto-emission of the response is enabled.\n  \ngetServiceMap()\n: Retrieve the service map description in the form of a\n  \nZend\\Json\\Server\\Smd\n object",
            "title": "Zend\\Json\\Server\\Server"
        },
        {
            "location": "/server/#zend92json92server92server",
            "text": "Zend\\Json\\Server\\Server  is the core class in the JSON-RPC offering; it\nhandles all requests and returns the response payload. It has the following\nmethods:   addFunction($function) : Specify a userland function to attach to the server.  setClass($class) : Specify a class or object to attach to the server; all\n  public methods of that item will be exposed as JSON-RPC methods.  fault($fault = null, $code = 404, $data = null) : Create and return a\n   Zend\\Json\\Server\\Error  object.  handle($request = false) : Handle a JSON-RPC request; optionally, pass a\n   Zend\\Json\\Server\\Request  object to utilize (creates one by default).  getFunctions() : Return a list of all attached methods.  setRequest(Zend\\Json\\Server\\Request $request) : Specify a request object for\n  the server to utilize.  getRequest() : Retrieve the request object used by the server.  setResponse(Zend\\Json\\Server\\Response $response) : Set the response object\n  for the server to utilize.  getResponse() : Retrieve the response object used by the server.  setAutoEmitResponse($flag) : Indicate whether the server should\n  automatically emit the response and all headers; by default, this is  TRUE .  autoEmitResponse() : Determine if auto-emission of the response is enabled.\n   getServiceMap() : Retrieve the service map description in the form of a\n   Zend\\Json\\Server\\Smd  object",
            "title": "Zend\\Json\\Server\\Server"
        },
        {
            "location": "/request/",
            "text": "Zend\\Json\\Server\\Request\n\n\nThe JSON-RPC request environment is encapsulated in the\n\nZend\\Json\\Server\\Request\n object. This object allows you to set necessary\nportions of the JSON-RPC request, including the request ID, parameters, and\nJSON-RPC specification version. It has the ability to load itself via JSON or\na set of options, and can render itself as JSON via the \ntoJson()\n method.\n\n\nThe request object has the following methods available:\n\n\n\n\nsetOptions(array $options)\n: Specify object configuration. \n$options\n may\n  contain keys matching any 'set' method: \nsetParams()\n, \nsetMethod()\n,\n  \nsetId()\n, and \nsetVersion()\n.\n\n\naddParam($value, $key = null)\n: Add a parameter to use with the method call.\n  Parameters can be just the values, or can optionally include the parameter\n  name.\n\n\naddParams(array $params)\n: Add multiple parameters at once; proxies to\n  \naddParam()\n.\n\n\nsetParams(array $params)\n: Set all parameters at once; overwrites any\n  existing parameters.\n\n\ngetParam($index)\n: Retrieve a parameter by position or name.\n\n\ngetParams()\n: Retrieve all parameters at once.\n\n\nsetMethod($name)\n: Set the method to call.\n\n\ngetMethod()\n: Retrieve the method that will be called.\n\n\nisMethodError()\n: Determine whether or not the request is malformed and\n  would result in an error.\n\n\nsetId($name)\n: Set the request identifier (used by the client to match\n  requests to responses).\n\n\ngetId()\n: Retrieve the request identifier.\n\n\nsetVersion($version)\n: Set the JSON-RPC specification version the request\n  conforms to. May be either '1.0' or '2.0'.\n\n\ngetVersion()\n: Retrieve the JSON-RPC specification version used by the\n  request.\n\n\nloadJson($json)\n: Load the request object from a JSON string.\n\n\ntoJson()\n: Render the request as a JSON string.\n\n\n\n\nAn HTTP specific version is available via \nZend\\Json\\Server\\Request\\Http\n. This\nclass will retrieve the request via \nphp://input\n, and allows access to the raw\nJSON via the \ngetRawJson()\n method.",
            "title": "Zend\\Json\\Server\\Request"
        },
        {
            "location": "/request/#zend92json92server92request",
            "text": "The JSON-RPC request environment is encapsulated in the Zend\\Json\\Server\\Request  object. This object allows you to set necessary\nportions of the JSON-RPC request, including the request ID, parameters, and\nJSON-RPC specification version. It has the ability to load itself via JSON or\na set of options, and can render itself as JSON via the  toJson()  method.  The request object has the following methods available:   setOptions(array $options) : Specify object configuration.  $options  may\n  contain keys matching any 'set' method:  setParams() ,  setMethod() ,\n   setId() , and  setVersion() .  addParam($value, $key = null) : Add a parameter to use with the method call.\n  Parameters can be just the values, or can optionally include the parameter\n  name.  addParams(array $params) : Add multiple parameters at once; proxies to\n   addParam() .  setParams(array $params) : Set all parameters at once; overwrites any\n  existing parameters.  getParam($index) : Retrieve a parameter by position or name.  getParams() : Retrieve all parameters at once.  setMethod($name) : Set the method to call.  getMethod() : Retrieve the method that will be called.  isMethodError() : Determine whether or not the request is malformed and\n  would result in an error.  setId($name) : Set the request identifier (used by the client to match\n  requests to responses).  getId() : Retrieve the request identifier.  setVersion($version) : Set the JSON-RPC specification version the request\n  conforms to. May be either '1.0' or '2.0'.  getVersion() : Retrieve the JSON-RPC specification version used by the\n  request.  loadJson($json) : Load the request object from a JSON string.  toJson() : Render the request as a JSON string.   An HTTP specific version is available via  Zend\\Json\\Server\\Request\\Http . This\nclass will retrieve the request via  php://input , and allows access to the raw\nJSON via the  getRawJson()  method.",
            "title": "Zend\\Json\\Server\\Request"
        },
        {
            "location": "/response/",
            "text": "Zend\\Json\\Server\\Response\n\n\nThe JSON-RPC response payload is encapsulated in the\n\nZend\\Json\\Server\\Response\n object. This object allows you to set the return\nvalue of the request, whether or not the response is an error, the request\nidentifier, the JSON-RPC specification version the response conforms to, and\noptionally the service map.\n\n\nThe response object has the following methods available:\n\n\n\n\nsetResult($value)\n: Set the response result.\n\n\ngetResult()\n: Retrieve the response result.\n\n\nsetError(Zend\\Json\\Server\\Error $error)\n: Set an error object. If set, this\n  will be used as the response when serializing to JSON.\n\n\ngetError()\n: Retrieve the error object, if any.\n\n\nisError()\n: Whether or not the response is an error response.\n\n\nsetId($name)\n: Set the request identifier (so the client may match the\n  response with the original request).\n\n\ngetId()\n: Retrieve the request identifier.\n\n\nsetVersion($version)\n: Set the JSON-RPC version the response conforms to.\n\n\ngetVersion()\n: Retrieve the JSON-RPC version the response conforms to.\n\n\ntoJson()\n: Serialize the response to JSON. If the response is an error\n  response, serializes the error object.\n\n\nsetServiceMap($serviceMap)\n: Set the service map object for the response.\n\n\ngetServiceMap()\n: Retrieve the service map object, if any.\n\n\n\n\nAn HTTP specific version is available via \nZend\\Json\\Server\\Response\\Http\n.\nThis class will send the appropriate HTTP headers as well as serialize the\nresponse as JSON.",
            "title": "Zend\\Json\\Server\\Response"
        },
        {
            "location": "/response/#zend92json92server92response",
            "text": "The JSON-RPC response payload is encapsulated in the Zend\\Json\\Server\\Response  object. This object allows you to set the return\nvalue of the request, whether or not the response is an error, the request\nidentifier, the JSON-RPC specification version the response conforms to, and\noptionally the service map.  The response object has the following methods available:   setResult($value) : Set the response result.  getResult() : Retrieve the response result.  setError(Zend\\Json\\Server\\Error $error) : Set an error object. If set, this\n  will be used as the response when serializing to JSON.  getError() : Retrieve the error object, if any.  isError() : Whether or not the response is an error response.  setId($name) : Set the request identifier (so the client may match the\n  response with the original request).  getId() : Retrieve the request identifier.  setVersion($version) : Set the JSON-RPC version the response conforms to.  getVersion() : Retrieve the JSON-RPC version the response conforms to.  toJson() : Serialize the response to JSON. If the response is an error\n  response, serializes the error object.  setServiceMap($serviceMap) : Set the service map object for the response.  getServiceMap() : Retrieve the service map object, if any.   An HTTP specific version is available via  Zend\\Json\\Server\\Response\\Http .\nThis class will send the appropriate HTTP headers as well as serialize the\nresponse as JSON.",
            "title": "Zend\\Json\\Server\\Response"
        },
        {
            "location": "/error/",
            "text": "Zend\\Json\\Server\\Error\n\n\nJSON-RPC has a special format for reporting error conditions. All errors need\nto provide, minimally, an error message and error code; optionally, they can\nprovide additional data, such as a backtrace.\n\n\nError codes are derived from those recommended by \nthe XML-RPC EPI project\n.\n\nZend\\Json\\Server\n appropriately assigns the code based on the error condition.\nFor application exceptions, the code '-32000' is used.\n\n\nZend\\Json\\Server\\Error\n exposes the following methods:\n\n\n\n\nsetCode($code)\n: Set the error code; if the code is not in the accepted\n  XML-RPC error code range, -32000 will be assigned.\n\n\ngetCode()\n: Retrieve the current error code.\n\n\nsetMessage($message)\n: Set the error message.\n\n\ngetMessage()\n: Retrieve the current error message.\n\n\nsetData($data)\n: Set auxiliary data further qualifying the error, such as a\n  backtrace.\n\n\ngetData()\n: Retrieve any current auxiliary error data.\n\n\ntoArray()\n: Cast the error to an array. The array will contain the keys\n  'code', 'message', and 'data'.\n\n\ntoJson()\n: Cast the error to a JSON-RPC error representation.",
            "title": "Zend\\Json\\Server\\Error"
        },
        {
            "location": "/error/#zend92json92server92error",
            "text": "JSON-RPC has a special format for reporting error conditions. All errors need\nto provide, minimally, an error message and error code; optionally, they can\nprovide additional data, such as a backtrace.  Error codes are derived from those recommended by  the XML-RPC EPI project . Zend\\Json\\Server  appropriately assigns the code based on the error condition.\nFor application exceptions, the code '-32000' is used.  Zend\\Json\\Server\\Error  exposes the following methods:   setCode($code) : Set the error code; if the code is not in the accepted\n  XML-RPC error code range, -32000 will be assigned.  getCode() : Retrieve the current error code.  setMessage($message) : Set the error message.  getMessage() : Retrieve the current error message.  setData($data) : Set auxiliary data further qualifying the error, such as a\n  backtrace.  getData() : Retrieve any current auxiliary error data.  toArray() : Cast the error to an array. The array will contain the keys\n  'code', 'message', and 'data'.  toJson() : Cast the error to a JSON-RPC error representation.",
            "title": "Zend\\Json\\Server\\Error"
        },
        {
            "location": "/smd/",
            "text": "SMD: Service Mapping Description\n\n\nSMD stands for Service Mapping Description, a JSON schema that defines how a\nclient can interact with a particular web service. At the time of this writing,\nthe \nspecification\n has not yet been\nformally ratified, but it is in use already within Dojo Toolkit as well as\nother JSON-RPC consumer clients.\n\n\nAt its most basic, a Service Mapping Description indicates the method of\ntransport (\nPOST\n, \nGET\n, TCP/IP, etc), the request envelope type (usually\nbased on the protocol of the server), the target URL of the service provider,\nand a map of services available. In the case of JSON-RPC, the service map is a\nlist of available methods, which each method documenting the available\nparameters and their types, as well as the expected return value type.\n\n\nZend\\Json\\Server\\Smd\n provides an object-oriented way to build service maps.\nAt its most basic, you pass it metadata describing the service using mutators,\nand specify services (methods and functions).\n\n\nThe service descriptions themselves are typically instances of\n\nZend\\Json\\Server\\Smd\\Service\n; you can also pass all information as an array\nto the various service mutators in \nZend\\Json\\Server\\Smd\n, and it will\ninstantiate a service for you. The service objects contain information such as\nthe name of the service (typically the function or method name), the parameters\n(names, types, and position), and the return value type. Optionally, each\nservice can have its own target and envelope, though this functionality is\nrarely used.\n\n\nZend\\Json\\Server\\Server\n actually does all of this behind the scenes for you,\nby using reflection on the attached classes and functions; you should create\nyour own service maps only if you need to provide custom functionality that\nclass and function introspection cannot offer.\n\n\nMethods available in \nZend\\Json\\Server\\Smd\n include:\n\n\n\n\nsetOptions(array $options)\n: Setup an SMD object from an array of options.\n  All mutators (methods beginning with 'set') can be used as keys.\n\n\nsetTransport($transport)\n: Set the transport used to access the service;\n  only POST is currently supported.\n\n\ngetTransport()\n: Get the current service transport.\n\n\nsetEnvelope($envelopeType)\n: Set the request envelope that should be used to\n  access the service.  Currently, supports the constants\n  \nZend\\Json\\Server\\Smd::ENV_JSONRPC_1\n and\n  \nZend\\Json\\Server\\Smd::ENV_JSONRPC_2\n.\n\n\ngetEnvelope()\n: Get the current request envelope.\n\n\nsetContentType($type)\n: Set the content type requests should use (by\n  default, this is 'application/json').\n\n\ngetContentType()\n: Get the current content type for requests to the service.\n\n\nsetTarget($target)\n: Set the URL endpoint for the service.\n\n\ngetTarget()\n: Get the URL endpoint for the service.\n\n\nsetId($id)\n: Typically, this is the URL endpoint of the service (same as the\n  target).\n\n\ngetId()\n: Retrieve the service ID (typically the URL endpoint of the\n  service).\n\n\nsetDescription($description)\n: Set a service description (typically\n  narrative information describing the purpose of the service).\n\n\ngetDescription()\n: Get the service description.\n\n\nsetDojoCompatible($flag)\n: Set a flag indicating whether or not the SMD is\n  compatible with Dojo toolkit. When \nTRUE\n, the generated JSON SMD will be\n  formatted to comply with the format that Dojo's JSON-RPC client expects.\n\n\nisDojoCompatible()\n: Returns the value of the Dojo compatibility flag\n  (\nFALSE\n, by default).\n\n\naddService($service)\n: Add a service to the map. May be an array of\n  information to pass to the constructor of \nZend\\Json\\Server\\Smd\\Service\n, or\n  an instance of that class.\n\n\naddServices(array $services)\n: Add multiple services at once.\n\n\nsetServices(array $services)\n: Add multiple services at once, overwriting\n  any previously set services.\n\n\ngetService($name)\n: Get a service by its name.\n\n\ngetServices()\n: Get all attached services.\n\n\nremoveService($name)\n: Remove a service from the map.\n\n\ntoArray()\n: Cast the service map to an array.\n\n\ntoDojoArray()\n: Cast the service map to an array compatible with Dojo\n  Toolkit.\n\n\ntoJson()\n: Cast the service map to a JSON representation.\n\n\n\n\nZend\\Json\\Server\\Smd\\Service\n has the following methods:\n\n\n\n\nsetOptions(array $options)\n: Set object state from an array. Any mutator\n  (methods beginning with 'set') may be used as a key and set via this method.\n\n\nsetName($name)\n: Set the service name (typically, the function or method\n  name).\n\n\ngetName()\n: Retrieve the service name.\n\n\nsetTransport($transport)\n: Set the service transport (currently, only\n  transports supported by \nZend\\Json\\Server\\Smd\n are allowed).\n\n\ngetTransport()\n: Retrieve the current transport.\n\n\nsetTarget($target)\n: Set the URL endpoint of the service (typically, this\n  will be the same as the overall SMD to which the service is attached).\n\n\ngetTarget()\n: Get the URL endpoint of the service.\n\n\nsetEnvelope($envelopeType)\n: Set the service envelope (currently, only\n  envelopes supported by \nZend\\Json\\Server\\Smd\n are allowed).\n\n\ngetEnvelope()\n: Retrieve the service envelope type.\n  \naddParam($type, array $options = array(), $order = null)\n: Add a parameter\n  to the service. By default, only the parameter type is necessary. However,\n  you may also specify the order, as well as options such as:\n\n\nname\n: the parameter name\n\n\noptional\n: whether or not the parameter is optional\n\n\ndefault\n: a default value for the parameter\n\n\ndescription\n: text describing the parameter\n\n\n\n\n\n\naddParams(array $params)\n: Add several parameters at once; each param should\n  be an assoc array containing minimally the key 'type' describing the\n  parameter type, and optionally the key 'order'; any other keys will be passed\n  as \n$options\n to \naddOption()\n.\n\n\nsetParams(array $params)\n: Set many parameters at once, overwriting any\n  existing parameters.\n\n\ngetParams()\n: Retrieve all currently set parameters.\n\n\nsetReturn($type)\n: Set the return value type of the service.\n\n\ngetReturn()\n: Get the return value type of the service.\n\n\ntoArray()\n: Cast the service to an array.\n\n\ntoJson()\n: Cast the service to a JSON representation.",
            "title": "Service Mapping Description (SMD)"
        },
        {
            "location": "/smd/#smd-service-mapping-description",
            "text": "SMD stands for Service Mapping Description, a JSON schema that defines how a\nclient can interact with a particular web service. At the time of this writing,\nthe  specification  has not yet been\nformally ratified, but it is in use already within Dojo Toolkit as well as\nother JSON-RPC consumer clients.  At its most basic, a Service Mapping Description indicates the method of\ntransport ( POST ,  GET , TCP/IP, etc), the request envelope type (usually\nbased on the protocol of the server), the target URL of the service provider,\nand a map of services available. In the case of JSON-RPC, the service map is a\nlist of available methods, which each method documenting the available\nparameters and their types, as well as the expected return value type.  Zend\\Json\\Server\\Smd  provides an object-oriented way to build service maps.\nAt its most basic, you pass it metadata describing the service using mutators,\nand specify services (methods and functions).  The service descriptions themselves are typically instances of Zend\\Json\\Server\\Smd\\Service ; you can also pass all information as an array\nto the various service mutators in  Zend\\Json\\Server\\Smd , and it will\ninstantiate a service for you. The service objects contain information such as\nthe name of the service (typically the function or method name), the parameters\n(names, types, and position), and the return value type. Optionally, each\nservice can have its own target and envelope, though this functionality is\nrarely used.  Zend\\Json\\Server\\Server  actually does all of this behind the scenes for you,\nby using reflection on the attached classes and functions; you should create\nyour own service maps only if you need to provide custom functionality that\nclass and function introspection cannot offer.  Methods available in  Zend\\Json\\Server\\Smd  include:   setOptions(array $options) : Setup an SMD object from an array of options.\n  All mutators (methods beginning with 'set') can be used as keys.  setTransport($transport) : Set the transport used to access the service;\n  only POST is currently supported.  getTransport() : Get the current service transport.  setEnvelope($envelopeType) : Set the request envelope that should be used to\n  access the service.  Currently, supports the constants\n   Zend\\Json\\Server\\Smd::ENV_JSONRPC_1  and\n   Zend\\Json\\Server\\Smd::ENV_JSONRPC_2 .  getEnvelope() : Get the current request envelope.  setContentType($type) : Set the content type requests should use (by\n  default, this is 'application/json').  getContentType() : Get the current content type for requests to the service.  setTarget($target) : Set the URL endpoint for the service.  getTarget() : Get the URL endpoint for the service.  setId($id) : Typically, this is the URL endpoint of the service (same as the\n  target).  getId() : Retrieve the service ID (typically the URL endpoint of the\n  service).  setDescription($description) : Set a service description (typically\n  narrative information describing the purpose of the service).  getDescription() : Get the service description.  setDojoCompatible($flag) : Set a flag indicating whether or not the SMD is\n  compatible with Dojo toolkit. When  TRUE , the generated JSON SMD will be\n  formatted to comply with the format that Dojo's JSON-RPC client expects.  isDojoCompatible() : Returns the value of the Dojo compatibility flag\n  ( FALSE , by default).  addService($service) : Add a service to the map. May be an array of\n  information to pass to the constructor of  Zend\\Json\\Server\\Smd\\Service , or\n  an instance of that class.  addServices(array $services) : Add multiple services at once.  setServices(array $services) : Add multiple services at once, overwriting\n  any previously set services.  getService($name) : Get a service by its name.  getServices() : Get all attached services.  removeService($name) : Remove a service from the map.  toArray() : Cast the service map to an array.  toDojoArray() : Cast the service map to an array compatible with Dojo\n  Toolkit.  toJson() : Cast the service map to a JSON representation.   Zend\\Json\\Server\\Smd\\Service  has the following methods:   setOptions(array $options) : Set object state from an array. Any mutator\n  (methods beginning with 'set') may be used as a key and set via this method.  setName($name) : Set the service name (typically, the function or method\n  name).  getName() : Retrieve the service name.  setTransport($transport) : Set the service transport (currently, only\n  transports supported by  Zend\\Json\\Server\\Smd  are allowed).  getTransport() : Retrieve the current transport.  setTarget($target) : Set the URL endpoint of the service (typically, this\n  will be the same as the overall SMD to which the service is attached).  getTarget() : Get the URL endpoint of the service.  setEnvelope($envelopeType) : Set the service envelope (currently, only\n  envelopes supported by  Zend\\Json\\Server\\Smd  are allowed).  getEnvelope() : Retrieve the service envelope type.\n   addParam($type, array $options = array(), $order = null) : Add a parameter\n  to the service. By default, only the parameter type is necessary. However,\n  you may also specify the order, as well as options such as:  name : the parameter name  optional : whether or not the parameter is optional  default : a default value for the parameter  description : text describing the parameter    addParams(array $params) : Add several parameters at once; each param should\n  be an assoc array containing minimally the key 'type' describing the\n  parameter type, and optionally the key 'order'; any other keys will be passed\n  as  $options  to  addOption() .  setParams(array $params) : Set many parameters at once, overwriting any\n  existing parameters.  getParams() : Retrieve all currently set parameters.  setReturn($type) : Set the return value type of the service.  getReturn() : Get the return value type of the service.  toArray() : Cast the service to an array.  toJson() : Cast the service to a JSON representation.",
            "title": "SMD: Service Mapping Description"
        }
    ]
}